
# Setting up the IPython notebook
**Import pandas, Numpy and datetime** 
```{python}
 import numpy as np 
 ```
 ```{python}
 import pandas as pd 
 ```
 ```{python}
 import datetime
 ```
 **Set some pandas options for controlling output** 
 ```{python}
 pd.set_option('display.notebook_repr_html', False)
 ```
 ```{python}
  pd.set_option('display.max_columns', 10)
 ```
 ```{python}
  pd.set_option('display.max_rows', 10)
 ```

# Working with missing data
**create a DataFrame with 5 rows and 3 columns** 
 ```{python}
 df = pd.DataFrame(np.arange(0, 15).reshape(5, 3),  
 index=['a', 'b', 'c', 'd', 'e'],  
 columns=['c1', 'c2', 'c3']) 
 df 
 ```

**add some columns and rows to the DataFrame** 
**column c4 with NaN values** 
```{python}
 df['c4'] = np.nan
 ```

**row 'f' with 15 through 18**
  ```{python}
 df.loc['f'] = np.arange(15, 19)
 ```

**row 'g' will all NaN**
 ```{python}
 df.loc['g'] = np.nan
 ```

**column 'C5' with NaN's**
 ```{python}
 df['c5'] = np.nan
 ```

**change value in col 'c4' row 'a'**
 ```{python}
 df.loc['a', 'c4'] = 20 #aquí es donde pasa el error, se solucionó  agregando .loc
 df
 ```

 # Determining NaN values in Series and  DataFrame objects 
**which items are NaN?** 
```{python}
 df.isnull() 
 ```
**count the number of NaN values in each column**
```{python}
 df.isnull().sum()
 ```

 **total count of NaN values**
 ```{python}
 df.isnull().sum().sum()
 ```
 **number of non-NaN values in each column**
 ```{python}
 df.count()
 ```
 **and this counts the number of NaN values too**
 ```{python}
 (len(df) - df.count()).sum()
 ```
**which items are not null?**
 ```{python}
 df.notnull()
 ```
 # Selecting out or dropping missing data
 **select the non-NaN items in column c4**
 ```{python}
 df.c4[df.c4.notnull()]
 ```
 **dropna will also return non NaN values**
 **this gets all non NaN items in column c4**
 ```{python}
  df.c4.dropna() 
 ```
 **dropna returns a copy with the values dropped**
 **the source DataFrame / column is not changed**
 ```{python}
 df.c4
 ```
 **on a DataFrame this will drop entire rows where there is at least one NaN, in this case, that is all rows**
 ```{python}
 df.dropna()
 ```
 **using how='all', only rows that have all values as NaN will be dropped**
 ```{python}
 df.dropna(how = 'all')
 ```
**flip to drop columns instead of rows**
```{python}
 df.dropna(how='all', axis=1) # say goodbye to c5
 ```
**make a copy of df**
```{python}
 df2 = df.copy()
 ```
**replace two NaN cells with values** # Lo estoy cambiando por un 5
 ```{python}
 df.loc['g','c1' ] = 0 
 df.loc['g','c3' ] = 0 
 #acá tambien dió error, se cambió df2.ix['g'].c1 por df.loc['g','c1' ]
 ```
 ```{python}
print(df)
 ```
**now drop columns with any NaN values**
```{python}
 df2.dropna(how='any', axis=1)
 ```
**only drop columns with at least 5 NaN values**
```{python}
 df.dropna(thresh=5, axis=1)
 ```
# How pandas handles NaN values in  mathematical operations
**create a NumPy array with one NaN value** 
```{python}
 a = np.array([1, 2, np.nan, 3])
 ```
**create a Series from the array** 
 ```{python}
 s = pd.Series(a) 
 ```
**the mean of each is different**
```{python}
  a.mean(), s.mean()
 ```
 **demonstrate sum, mean and cumsum handling of NaN** 
 **get one column:**
 ```{python}
  s = df.c4
  s.sum() # NaN values treated as 0
 ```
```{python}
 s.mean() # NaN also treated as 0 
 ```
 **as 0 in the cumsum, but NaN values preserved in result Series**
```{python}
 s.cumsum()
 ```
 **# in arithmetic, a NaN value will result in NaN**
```{python}
 df.c4 + 1
 ```
# Filling in missing data
**return a new DataFrame with NaN values filled with 0**
```{python}
 filled = df.fillna(0)
 filled
 ```
**NaNs don't count as an item in calculating # the means**
 ```{python}
 df.mean()
 ```
**having replaced NaN with 0 can make operations such as mean have different results**
 ```{python}
 filled.mean()
 ```
**only fills the first two NaN values in each row with 0**
```{python}
 df.fillna(0, limit=2)
 ```
# Forward and backward flling of missing  values
**extract the c4 column and fill NaNs forward** 
```{python}
 df.c4.fillna(method="ffill")
 ```
**perform a backwards fill** 
```{python}
df.c4.fillna(method="bfill")
 ```
# Filling using index labels
**create a new Series of values to be used to fill NaN values where the index label matches**
```{python}
 fill_values = pd.Series([100, 101, 102], index=['a', 'e', 'g'])  
 fill_values
 ```
**using c4, fill using fill_values a, e and g will be filled with matching values** 
```{python}
 df.c4.fillna(fill_values)
 ```
**fill NaN values in each column with the mean of the values in that column** 
```{python}
 df.fillna(df.mean())
 ```
# Interpolation of missing values 
**linear interpolate the NaN values from 1 through 2**
```{python}
s = pd.Series([1, np.nan, np.nan, np.nan, 2]) 
s.interpolate()
 ```

 





 



  

  









 